<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>High Risk Plinko</title>

<style>
  body {
    margin: 0;
    font-family: sans-serif;
    background: #1e1e1e;
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  canvas {
    background: #2a2a2a;
    border: 2px solid white;
    margin-top: 20px;
  }

  button {
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    margin-top: 10px;
  }

  .back-btn {
    position: fixed;
    top: 15px;
    left: 15px;
  }
</style>
</head>

<body>

<button class="back-btn" onclick="window.location.href='index.html'">
  ⬅ Back to Menu
</button>

<h1>High Risk Plinko</h1>

<canvas id="plinkoCanvas" width="600" height="750"></canvas>

<button onclick="dropBall()">Drop Ball ($10)</button>

<h2 id="money">Money: $100.00</h2>

<script>
const canvas = document.getElementById("plinkoCanvas");
const ctx = canvas.getContext("2d");

/* ---------- PHYSICS ---------- */
const gravity = 0.4;
const friction = 0.6;

const ballRadius = 7;
const pegRadius = 5;

let balls = [];
let money = 100;
const ballCost = 10;

/* ---------- BOARD SIZE ---------- */
const rows = 14;              // MORE ROWS = MORE PINS
const spacingY = 45;

/* ---------- PEGS ---------- */
const pegs = [];
for (let r = 0; r < rows; r++) {
  for (let c = 0; c <= r; c++) {
    pegs.push({
      x: canvas.width / 2 - r * 22 + c * 44,
      y: 60 + r * spacingY
    });
  }
}

/* ---------- BINS & MULTIPLIERS ---------- */
const binWidth = canvas.width / numBins;

let index = Math.floor(ball.x / binWidth);

// CLAMP index so it never breaks
index = Math.max(0, Math.min(index, bins.length - 1));

const multiplier = bins[index];

if (Number.isFinite(multiplier)) {
  money += ballCost * multiplier;
}


  /*
    VERY risky curve:
    Center ≈ 0.2x
    Edges ≈ 8x+
  */
  const multiplier = 0.2 + Math.pow(distance, 1.7) * 0.25;
  bins.push(multiplier);
}

/* ---------- DRAW ---------- */
function drawPegs() {
  ctx.fillStyle = "white";
  pegs.forEach(p => {
    ctx.beginPath();
    ctx.arc(p.x, p.y, pegRadius, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawBins() {
  const binWidth = canvas.width / numBins;

  ctx.strokeStyle = "white";
  ctx.lineWidth = 2;

  for (let i = 0; i <= numBins; i++) {
    ctx.beginPath();
    ctx.moveTo(i * binWidth, canvas.height - 70);
    ctx.lineTo(i * binWidth, canvas.height);
    ctx.stroke();
  }

  ctx.font = "14px sans-serif";
  bins.forEach((m, i) => {
    const color =
      m > 5 ? "red" :
      m > 2 ? "orange" :
      "lime";

    ctx.fillStyle = color;
    ctx.fillText(m.toFixed(2) + "x", i * binWidth + 8, canvas.height - 75);
  });
}

function drawBalls() {
  ctx.fillStyle = "yellow";
  balls.forEach(b => {
    ctx.beginPath();
    ctx.arc(b.x, b.y, ballRadius, 0, Math.PI * 2);
    ctx.fill();
  });
}

/* ---------- COLLISIONS ---------- */
function collideBall(ball, peg) {
  const dx = ball.x - peg.x;
  const dy = ball.y - peg.y;
  const dist = Math.hypot(dx, dy);

  if (dist < ballRadius + pegRadius) {
    const angle = Math.atan2(dy, dx);

    ball.x = peg.x + Math.cos(angle) * (ballRadius + pegRadius);
    ball.y = peg.y + Math.sin(angle) * (ballRadius + pegRadius);

    const speed = Math.hypot(ball.vx, ball.vy);
    const bounce = angle + (Math.random() < 0.5 ? -0.45 : 0.45);

    ball.vx = Math.cos(bounce) * speed * friction;
    ball.vy = Math.sin(bounce) * speed * friction;
  }
}

/* ---------- UPDATE ---------- */
function updateBalls() {
  balls.forEach(ball => {
    ball.vy += gravity;
    ball.x += ball.vx;
    ball.y += ball.vy;

    pegs.forEach(p => collideBall(ball, p));

    // Triangle walls
    const left = canvas.width / 2 - (ball.y / spacingY) * 22 - ballRadius;
    const right = canvas.width / 2 + (ball.y / spacingY) * 22 + ballRadius;

    if (ball.x < left) { ball.x = left; ball.vx *= -friction; }
    if (ball.x > right) { ball.x = right; ball.vx *= -friction; }

    // Bottom payout
    if (ball.y > canvas.height - ballRadius) {
      const binWidth = canvas.width / numBins;
      const index = Math.min(Math.floor(ball.x / binWidth), bins.length - 1);

      const payout = ballCost * bins[index];
      money += payout;

      document.getElementById("money").innerText =
        "Money: $" + money.toFixed(2);

      balls = balls.filter(b => b !== ball);
    }
  });
}

/* ---------- CONTROLS ---------- */
function dropBall() {
  if (money < ballCost) {
    alert("Not enough money!");
    return;
  }

  money -= ballCost;
  document.getElementById("money").innerText =
    "Money: $" + money.toFixed(2);

  balls.push({
    x: canvas.width / 2,
    y: 0,
    vx: (Math.random() - 0.5) * 2.5,
    vy: 0
  });
}

/* ---------- LOOP ---------- */
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawPegs();
  drawBins();
  updateBalls();
  drawBalls();
  requestAnimationFrame(animate);
}

animate();
</script>

</body>
</html>
