<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Solitaire</title>
  <style>
    :root{--green:#2b6b3a;--card-w:90px;--card-h:130px}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{background:linear-gradient(180deg,#0b6623,#134a2b);display:flex;align-items:flex-start;justify-content:center;padding:20px}
    .game{width:1100px;max-width:98%;}
    header{color:#fff;display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
    h1{font-size:18px;margin:0}
    .controls button{margin-left:8px;padding:8px 12px;border-radius:8px;border:none;background:#fff;color:#111;cursor:pointer}
    .board{display:grid;grid-template-columns:repeat(7,1fr);gap:12px}

    .top-row{display:flex;gap:12px;margin-bottom:12px}
    .slot{width:var(--card-w);height:var(--card-h);border-radius:8px;position:relative}
    .pile{min-height:var(--card-h);}

    .card{width:var(--card-w);height:var(--card-h);border-radius:8px;box-shadow:0 6px 14px rgba(0,0,0,0.45);position:absolute;left:0;top:0;user-select:none;display:flex;flex-direction:column;justify-content:space-between;padding:6px;font-weight:700;touch-action:none}
    .card.back{background:linear-gradient(180deg,#2f7f4a,#1b5b2f);color:transparent;}
    .card.front{background:#fff;color:#111}
    .card.red{color:#d33}
    .card .corner{font-size:12px}
    .pile .card{position:relative}
    .tableau{background:transparent}

    .tableau > .card{position:absolute;left:0}
    .tableau{position:relative;padding-bottom:10px;min-height:var(--card-h)}

    .foundations{display:flex;gap:12px;margin-left:auto}
    .foundations .slot{background:rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;border:1px dashed rgba(255,255,255,0.08)}

    .stock{cursor:pointer}
    .waste{min-width:var(--card-w)}

    .hint{color:#fff;opacity:0.9;margin-top:10px}

    footer{color:#fff;opacity:0.9;margin-top:14px}

    .drag-layer{position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:9999}
    .drag-item{position:absolute;transform-origin:0 0;will-change:transform;box-shadow:0 10px 30px rgba(0,0,0,0.6);}

    .valid-target{outline:3px solid rgba(50,200,50,0.7)}
    .invalid-target{outline:3px solid rgba(200,50,50,0.7)}

    @media (max-width:720px){:root{--card-w:66px;--card-h:96px}}
  </style>
</head>
<body>
<div class="game">
  <header>
    <h1>Solitaire (Klondike) — Drag & Drop</h1>
    <div class="controls">
      <button id="newBtn">New Game</button>
      <button id="undoBtn">Undo</button>
      <button id="autoBtn">Auto-Finish</button>
    </div>
  </header>

  <section class="top-row">
    <div class="left-top" style="display:flex;gap:12px;">
      <div id="stock" class="slot stock" title="Stock (tap/click to draw)"></div>
      <div id="waste" class="slot waste"></div>
    </div>

    <div style="flex:1"></div>

    <div class="foundations" id="foundations">
      <div class="slot" data-suit="hearts"></div>
      <div class="slot" data-suit="diamonds"></div>
      <div class="slot" data-suit="clubs"></div>
      <div class="slot" data-suit="spades"></div>
    </div>
  </section>

  <section class="board" id="tableau"></section>
  <div class="drag-layer" id="dragLayer"></div>
</div>

<script>
const suits = ['hearts','diamonds','clubs','spades'];
const ranks = [1,2,3,4,5,6,7,8,9,10,11,12,13];
let deck=[],stock=[],waste=[],foundations={},table=[[],[],[],[],[],[],[]],history=[];

const stockEl = document.getElementById('stock');
const wasteEl = document.getElementById('waste');
const foundationsEl = document.getElementById('foundations');
const tableauEl = document.getElementById('tableau');
const dragLayer = document.getElementById('dragLayer');

function createDeck(){ 
  const arr=[]; let id=0; 
  for(const s of suits) for(const r of ranks) arr.push({suit:s,rank:r,faceUp:false,id:id++}); 
  return arr; 
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } }

function startGame(){
  deck = createDeck(); shuffle(deck); 
  stock=[]; waste=[]; 
  foundations={hearts:[],diamonds:[],clubs:[],spades:[]}; 
  table=[[],[],[],[],[],[],[]]; history=[];
  
  let idx=0;
  for(let pile=0;pile<7;pile++){
    for(let i=0;i<=pile;i++){
      const card = Object.assign({},deck[idx++]);
      card.faceUp = (i===pile);
      table[pile].push(card);
    }
  }
  stock = deck.slice(idx).map(c=>Object.assign({},c,{faceUp:false}));
  render();
}

function saveState(){
  const state={
    stock:stock.map(c=>({...c})),
    waste:waste.map(c=>({...c})),
    foundations:{hearts:foundations.hearts.map(c=>({...c})),diamonds:foundations.diamonds.map(c=>({...c})),clubs:foundations.clubs.map(c=>({...c})),spades:foundations.spades.map(c=>({...c}))},
    table:table.map(p=>p.map(c=>({...c})))
  };
  history.push(state); if(history.length>200) history.shift();
}
function restoreState(){ if(history.length===0) return; const s=history.pop(); stock=s.stock; waste=s.waste; foundations=s.foundations; table=s.table; render(); }

function render(){
  stockEl.innerHTML=''; wasteEl.innerHTML=''; foundationsEl.querySelectorAll('.slot').forEach(el=>el.innerHTML=''); tableauEl.innerHTML='';
  
  if(stock.length>0){ const back=document.createElement('div'); back.className='card back'; stockEl.appendChild(back); }
  else { stockEl.style.border='1px dashed rgba(255,255,255,0.08)'; stockEl.style.borderRadius='8px'; }
  
  if(waste.length>0) wasteEl.appendChild(createCardEl(waste[waste.length-1]));

  suits.forEach((s,i)=>{
    const slot = foundationsEl.querySelectorAll('.slot')[i]; slot.innerHTML=''; slot.dataset.suit=s; 
    if(foundations[s].length>0) slot.appendChild(createCardEl(foundations[s][foundations[s].length-1]));
  });

  for(let i=0;i<7;i++){
    const pileEl = document.createElement('div'); pileEl.className='tableau'; pileEl.dataset.pile=i; pileEl.style.gridColumn=(i+1);
    const pile = table[i];
    pile.forEach((card,index)=>{
      const el = createCardEl(card);
      el.style.top=(index*28)+'px'; el.dataset.index=index;
      pileEl.appendChild(el);
    });
    tableauEl.appendChild(pileEl);
  }
}

function createCardEl(card){
  const el=document.createElement('div'); el.className='card '+(card.faceUp?'front':'back'); el.dataset.id=card.id;
  if(card.faceUp){
    const suitSym={hearts:'♥',diamonds:'♦',clubs:'♣',spades:'♠'}[card.suit];
    if(card.suit==='hearts'||card.suit==='diamonds') el.classList.add('red');
    el.innerHTML=`<div class="corner">${({1:'A',11:'J',12:'Q',13:'K'})[card.rank]||card.rank} ${suitSym}</div><div style="align-self:flex-end;font-size:22px">${suitSym}</div>`;
  }
  el.addEventListener('pointerdown', onPointerDownCard);
  el.addEventListener('dblclick', ()=>{ onDoubleClick(card.id); });
  return el;
}

// Drag & drop simplified and fixed
let dragSession=null;
function onPointerDownCard(e){
  e.preventDefault(); const target = e.currentTarget; const cardId=Number(target.dataset.id);
  const loc=findCardLocation(cardId); if(!loc) return; if(loc.type==='table' && !loc.card.faceUp) return;
  let movingStack=[];
  if(loc.type==='waste') movingStack=[waste[waste.length-1]];
  else if(loc.type==='table') movingStack=table[loc.pile].slice(loc.index);
  else return;
  
  const startX=e.clientX, startY=e.clientY;
  const srcEls=[];
  if(loc.type==='waste'){ const el=wasteEl.querySelector('.card'); if(el) srcEls.push(el);}
  else { const pileEl=tableauEl.querySelector(`.tableau[data-pile="${loc.pile}"]`); if(pileEl){ srcEls.push(...Array.from(pileEl.querySelectorAll('.card')).slice(loc.index)); } }

  const clones=[];
  srcEls.forEach((src,idx)=>{
    const r=src.getBoundingClientRect();
    const clone=src.cloneNode(true); clone.classList.add('drag-item');
    clone.style.width=r.width+'px'; clone.style.height=r.height+'px';
    clone.style.left=r.left+'px'; clone.style.top=r.top+'px';
    clone.style.transform=`translate(0px,${idx*28}px)`; dragLayer.appendChild(clone); clones.push(clone);
    src.style.visibility='hidden';
  });

  dragSession={loc,movingStack,srcEls,clones,startX,startY,lastX:startX,lastY:startY,pointerId:e.pointerId};
  e.target.setPointerCapture(e.pointerId);
  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup', onPointerUp);
}
function onPointerMove(e){
  if(!dragSession||e.pointerId!==dragSession.pointerId) return;
  e.preventDefault();
  const dx=e.clientX-dragSession.startX, dy=e.clientY-dragSession.startY;
  dragSession.clones.forEach(c=>{
    const left=Number(c.style.left.replace('px',''))+dx-(dragSession.lastX-dragSession.startX);
    const top=Number(c.style.top.replace('px',''))+dy-(dragSession.lastY-dragSession.startY);
    c.style.left=left+'px'; c.style.top=top+'px';
  });
  dragSession.lastX=e.clientX; dragSession.lastY=e.clientY;

  clearTargetHighlights();
  const elUnder=document.elementFromPoint(e.clientX,e.clientY);
  const targetInfo=determineDropTarget(elUnder, dragSession.movingStack[0]);
  if(targetInfo) targetInfo.node.classList.add(targetInfo.valid?'valid-target':'invalid-target');
}
function onPointerUp(e){
  if(!dragSession||e.pointerId!==dragSession.pointerId) return;
  e.preventDefault();
  window.removeEventListener('pointermove', onPointerMove);
  window.removeEventListener('pointerup', onPointerUp);

  const elUnder=document.elementFromPoint(e.clientX,e.clientY);
  const targetInfo=determineDropTarget(elUnder, dragSession.movingStack[0]);
  if(targetInfo&&targetInfo.valid){ saveState(); performMove(dragSession,targetInfo); }

  dragSession.srcEls.forEach(s=>s.style.visibility=''); dragSession.clones.forEach(c=>c.remove());
  clearTargetHighlights(); dragSession=null; render();
}

function clearTargetHighlights(){ document.querySelectorAll('.valid-target,.invalid-target').forEach(el=>el.classList.remove('valid-target','invalid-target')); }

function determineDropTarget(node, movingCard){
  if(!node) return null;
  const slot=node.closest('.slot');
  if(slot && slot.parentElement===foundationsEl){
    const suit=slot.dataset.suit;
    const top=foundations[suit].length?foundations[suit][foundations[suit].length-1].rank:0;
    return {type:'foundation', suit, node:slot, valid:movingCard.rank===top+1 && movingCard.suit===suit};
  }
  const pileEl=node.closest('.tableau');
  if(pileEl){
    const pile=Number(pileEl.dataset.pile);
    return {type:'tableau', pile, node:pileEl, valid:canPlaceSequenceOnTableau([movingCard], table[pile])};
  }
  return null;
}

function performMove(session,targetInfo){
  const moving=session.movingStack;
  if(session.loc.type==='waste'){
    waste.pop();
    if(targetInfo.type==='foundation') foundations[targetInfo.suit].push(moving[0]);
    else if(targetInfo.type==='tableau') table[targetInfo.pile].push(moving[0]);
  } else if(session.loc.type==='table'){
    const fromPile=session.loc.pile; const movingIndex=session.loc.index;
    const movingStack=table[fromPile].slice(movingIndex);
    table[fromPile]=table[fromPile].slice(0,movingIndex);
    if(targetInfo.type==='foundation') foundations[targetInfo.suit].push(movingStack[0]);
    else if(targetInfo.type==='tableau') table[targetInfo.pile]=table[targetInfo.pile].concat(movingStack);
    if(table[fromPile].length>0) table[fromPile][table[fromPile].length-1].faceUp=true;
  }
}

function canPlaceSequenceOnTableau(stack,dest){
  const card=stack[0];
  if(dest.length===0) return card.rank===13;
  const top=dest[dest.length-1];
  return top.faceUp && ((card.suit==='hearts'||card.suit==='diamonds') !== (top.suit==='hearts'||top.suit==='diamonds')) && card.rank===top.rank-1;
}

function findCardLocation(id){
  if(waste.length && waste[waste.length-1].id===id) return {type:'waste', pile:null, index:waste.length-1, card:waste[waste.length-1]};
  for(let p=0;p<7;p++) for(let i=0;i<table[p].length;i++) if(table[p][i].id===id) return {type:'table', pile:p, index:i, card:table[p][i]};
  for(const s of suits) if(foundations[s].length && foundations[s][foundations[s].length-1].id===id) return {type:'foundation', suit:s, index:foundations[s].length-1};
  return null;
}

function onDoubleClick(cardId){
  const loc=findCardLocation(cardId); if(!loc) return;
  let card=null;
  if(loc.type==='waste') card=waste[waste.length-1];
  else if(loc.type==='table') card=table[loc.pile][loc.index];
  if(!card.faceUp) return;
  const top=foundations[card.suit].length?foundations[card.suit][foundations[card.suit].length-1].rank:0;
  if(card.rank===top+1){ saveState(); if(loc.type==='waste') foundations[card.suit].push(waste.pop()); else { table[loc.pile].pop(); foundations[card.suit].push(card); if(table[loc.pile].length>0) table[loc.pile][table[loc.pile].length-1].faceUp=true; } render(); checkWin(); }
}

stockEl.addEventListener('click', ()=>{
  saveState();
  if(stock.length===0){ stock=waste.map(c=>({...c,faceUp:false})).reverse(); waste=[]; render(); } 
  else { const c=stock.pop(); c.faceUp=true; waste.push(c); render(); }
});

document.getElementById('newBtn').addEventListener('click',()=>startGame());
document.getElementById('undoBtn').addEventListener('click',()=>restoreState());
document.getElementById('autoBtn').addEventListener('click',()=>{
  let moved=true, loops=0;
  while(moved && loops<500){ moved=autoFinishStep(); loops++; } checkWin();
});

function autoFinishStep(){
  if(waste.length>0){ const c=waste[waste.length-1]; const top=foundations[c.suit].length?foundations[c.suit][foundations[c.suit].length-1].rank:0; if(c.rank===top+1){ saveState(); foundations[c.suit].push(waste.pop()); render(); return true; } }
  for(let p=0;p<7;p++){ const pile=table[p]; if(pile.length===0) continue; const c=pile[pile.length-1]; if(!c.faceUp) continue; const top=foundations[c.suit].length?foundations[c.suit][foundations[c.suit].length-1].rank:0; if(c.rank===top+1){ saveState(); foundations[c.suit].push(pile.pop()); if(pile.length>0) pile[pile.length-1].faceUp=true; render(); return true; } }
  return false;
}

function checkWin(){ const total=Object.values(foundations).reduce((s,a)=>s+a.length,0); if(total===52) setTimeout(()=>alert('You won!'),200); }

startGame();
</script>
</body>
</html>
